#+begin_src clojurescript :tangle ../../src/client/login.cljs
(ns client.login
  (:require
   [client.view-models :refer [create-room-list-vm]]
   [reagent.core :as r]
   [promesa.core :as p]
   [client.state :refer [sdk-world]]
  [client.session-store :refer [SessionStore]]
  [client.sdk-ctrl :as sdk-ctrl]
   ["generated-compat" :as sdk]
   ["@element-hq/web-shared-components" :refer [RoomListView BaseViewModel]])
  (:require-macros [macros :refer [ocall oget]])
  )
#+end_src


This serves as a ready check for the WASM (and our global sdk-world).
We can not start the application until the WASM has loaded.
In theory we could optimize around this by loading up components
in the background so it feels snappy though. No client behavior can be ran
though.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defonce sdk-ready? (r/atom false))
  (defn init-sdk! []
    (-> (p/let [_ (sdk/uniffiInitAsync)]
          (js/console.log "WASM loaded")
          (reset! sdk-ready? true)
          (swap! sdk-world assoc :loading? false))
        (p/catch (fn [e]
                   (js/console.error "WASM Load Failed:" e)
                   (swap! sdk-world assoc :loading? false)))))
#+end_src


*** Starting the Client

This is more or less where we start our journey of actually interfacing with the
matrix-rust-sdk WASM bindings. Since the client initialization is relatively 'easy'
compared to actually making use of the information and state internally.
Obviously, looking to Aurora is a boon, but it will be a tad bit different as we
write this with ClojureScript in mind.


It seems that WASM needs camelCase after it is converted from Rust.
So entries_handle becomes entriesStream
We're currently just testing out the update triggering. We may wish to pull this logic out.
I would think writing mock systems from the start might allow for complex mocking later.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn start-sync! [client]
  (p/let [sync-service (-> (.syncService client) (.withOfflineMode) (.finish))
          rls-instance (.roomListService sync-service)
          room-list    (.allRooms rls-instance)]
    (let [rl-vm (create-room-list-vm #js {:client client :roomListService rls-instance})]
      (do
        (aset rl-vm "onUpdate"
              (fn [updates] (js/console.log "UPDATE TRIGGERED!" (alength updates))))
        (let [entries-result (.entriesWithDynamicAdapters room-list 200 rl-vm)]
            (aset rl-vm "entries_handle" (.entriesStream entries-result))
            (aset rl-vm "controller" (.controller entries-result)))
          (swap! sdk-world assoc-in [:vms :room-list] rl-vm)
          (.start sync-service)
          (.setRange  (.-controller rl-vm) 0 50)
          (.addOnePage (.-controller rl-vm))
          (js/console.log "Background stream handle secured. Syncing...")))))
#+end_src


This actually was relatively quick to figure out, but the client builder merely takes
a few options. It is fairly dynamically configurable as is. Still, more time was spent
ensuring this could be used for both login and restore session.
So we allow nullish options in passphrase and store-id and if they're null
we generate them. If they are not null then we read from the value passed.
At the end of the process once the client object is 'built' we try to run the
login or restoreSession method depending on what is passed through to restore-or-login!
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn build-client [hs passphrase? store-id? restore-or-login!]
  (-> (p/let [
              ;; Rust internal components
              sdk-root (if (.-ClientBuilder sdk) sdk (.-default sdk))
              ClientBuilder (.-ClientBuilder sdk-root)
              SSVBuilder    (.-SlidingSyncVersionBuilder sdk-root)
              IDBBuilder    (.-IndexedDbStoreBuilder sdk-root)
              ;;
              store (SessionStore.)
              store-id   (or store-id? (.generateStoreId store))
              passphrase (or passphrase? (.generatePassphrase store))
              store-name (.getStoreName store store-id)
              store-config (-> (new IDBBuilder store-name)
                              (.passphrase passphrase))
              builder (-> (new ClientBuilder)
                        (.serverNameOrHomeserverUrl hs)
                        (.indexeddbStore store-config)
                        (.autoEnableCrossSigning true)
                        (cond-> (nil? passphrase)
                          (.slidingSyncVersionBuilder (.-DiscoverNative SSVBuilder))))
              client  (.build builder)
              _ (restore-or-login! client)
              session (.session client)
              _ (or passphrase? (.save store session passphrase store-id))
              ]
        client)
      (p/catch (fn [e]
                 (js/console.error e)
                 (js/console.warn "Login failed, returning nil")
                 nil))))
#+end_src





The login just passes on the home-server and an anonymous function
that expects the client object to run .login with the user and pass.
Features like this will ensure we can keep the codebase small and efficient.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn login! [hs user pass]
   (p/let [client (build-client hs nil nil #(.login % user pass))]
           client))
#+end_src

This is mostly the same deal as login, but we check the store for
an existing session. The actual session object is rehydrated when grabbed from the store
into the expected Rust object. The stored JSON doesn't actually have homeserverUrl in it after all.
We then also pass an anonymous function here where we expect the built client to be the object which
will have the function ran against it with our session variable. It's a very fancy callback.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn restore-client! [session passphrase store-id]
  (p/let [client (build-client (.-homeserverUrl session) passphrase store-id #(.restoreSession % session))]
    client))
#+end_src


This did make me think on an elegant logging implementation. I wouldn't be surprised if there are some
very fancy logging macro libraries that require little code change.
This is a helper function that checks for and returns the local session if it exists.
The local session exists as a JS Object once retrieved that represents the Rust object.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn maybe-local-session []
  (p/let [store (SessionStore.)
          sessions (.loadSessions store)
          user-id (first (js/Object.keys sessions))]
    (or (aget sessions user-id) nil)))
#+end_src

Now we can provide our application initialization and attempt to restore the previous login session.
If the previous login session is found, then we start-syncing and kick off the client's run.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn bootstrap! []
  (p/let [_ (init-sdk!)
          data? (maybe-local-session)
          client (restore-client!
                  (.-session data?) (.-passphrase data?) (.-storeId data?))]
        (start-sync! client)))
#+end_src

