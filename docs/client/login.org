#+begin_src clojurescript :tangle ../../src/client/login.cljs
(ns client.login
  (:require
   [client.view-models :refer [create-room-list-vm]]
   [reagent.core :as r]
   [promesa.core :as p]
   [client.state :refer [sdk-world]]
  [client.session-store :refer [SessionStore]]
  [client.sdk-ctrl :as sdk-ctrl]
   ["generated-compat" :as sdk]
   ["@element-hq/web-shared-components" :refer [RoomListView BaseViewModel]])
  (:require-macros [macros :refer [ocall oget]])
  )
#+end_src


#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defonce sdk-ready? (r/atom false))
  (defn init-sdk! []
    (-> (p/let [_ (sdk/uniffiInitAsync)]
          (js/console.log "WASM loaded")
          (reset! sdk-ready? true)
          (swap! sdk-world assoc :loading? false))
        (p/catch (fn [e]
                   (js/console.error "WASM Load Failed:" e)
                   (swap! sdk-world assoc :loading? false)))))
#+end_src


This is more or less where we start our journey of actually interfacing with the
matrix-rust-sdk WASM bindings. Since the client initialization is relatively 'easy'
compared to actually making use of the information and state internally.
Obviously, looking to Aurora is a boon, but it will be a tad bit different as we
write this with ClojureScript in mind.


It seems that WASM needs camelCase after it is converted from Rust...
So entries_handle becomes entriesStream
We're currently just testing out the update triggering. We may wish to pull this logic out.
I would think writing mock systems from the start might allow for complex mocking later.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn start-sync! [client]
  (p/let [sync-service (-> (.syncService client) (.withOfflineMode) (.finish))
          rls-instance (.roomListService sync-service)
          room-list    (.allRooms rls-instance)]
    (let [rl-vm (create-room-list-vm #js {:client client :roomListService rls-instance})]
      (do
        (aset rl-vm "onUpdate"
              (fn [updates] (js/console.log "UPDATE TRIGGERED!" (alength updates))))
        (let [entries-result (.entriesWithDynamicAdapters room-list 200 rl-vm)]
            (aset rl-vm "entries_handle" (.entriesStream entries-result))
            (aset rl-vm "controller" (.controller entries-result)))
          (swap! sdk-world assoc-in [:vms :room-list] rl-vm)
          (.start sync-service)
          (.setRange  (.-controller rl-vm) 0 50)
          (.addOnePage (.-controller rl-vm))
          (js/console.log "Background stream handle secured. Syncing...")))))
#+end_src


This actually was relatively quick to figure out, but the client builder merely takes
a few options. It is fairly dynamically configurable.
I'll likely return to this later to provide better descriptions of how it works
internally as these core components are unlikely to change inside the Rust SDK
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn login! [hs user pass on-success]
(let [sdk-root (if (.-ClientBuilder sdk) sdk (.-default sdk))
    ClientBuilder (.-ClientBuilder sdk-root)
    SSVBuilder    (.-SlidingSyncVersionBuilder sdk-root)
    IDBBuilder    (.-IndexedDbStoreBuilder sdk-root)]

(let [store (SessionStore.)]
(-> (p/let [
            store-id   (.generateStoreId store)
            passphrase (.generatePassphrase store)
            store-name (.getStoreName store store-id)
            store-config (-> (new IDBBuilder store-name)
                             (.passphrase passphrase))

            builder (-> (new ClientBuilder)
                        (.slidingSyncVersionBuilder (.-DiscoverNative SSVBuilder))
                        (.serverNameOrHomeserverUrl hs)
                        (.indexeddbStore store-config)
                        (.autoEnableCrossSigning true))
            client  (.build builder)
            _ (.login client user pass)
            session (.session client)]
      (js/console.log "Login successful. Negotiated version:" (.slidingSyncVersion client))
      (.save store session passphrase store-id)
      (on-success client))

    (p/catch (fn [e]
               (js/console.error "Login Error:" e)
               (js/alert (str "Login Failed: " (.-message e)))))))))
#+end_src


This is mostly the same deal as login, but we check the store for
an existing session. We should likely pull out the client building
into its own method so we can have a cleaner method to test again.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn restore-client! [session passphrase store-id on-success]
  (let [sdk-root (if (.-ClientBuilder sdk) sdk (.-default sdk))
        ClientBuilder (.-ClientBuilder sdk-root)
        IDBBuilder    (.-IndexedDbStoreBuilder sdk-root)
        store (SessionStore.)
        store-name (.getStoreName store store-id)]
    (js/console.log "Attempting to restore session for store:" store-name)
    (p/let [store-config (-> (new IDBBuilder store-name)
                             (.passphrase passphrase))
            builder (-> (new ClientBuilder)
                        (.homeserverUrl (.-homeserverUrl session))
                        (.indexeddbStore store-config)
                        (.autoEnableCrossSigning true))
            client (.build builder)]
      (.restoreSession client session)
      (js/console.log "Session Restored!")
      (on-success client))))
#+end_src



So we need a neat way to restore the session and if we can't restore
then we want to offer the login screen.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn bootstrap! []
(p/let [_ (init-sdk!)]
(let [store (SessionStore.)
      sessions (.loadSessions store)
      user-id (first (js/Object.keys sessions))]
  (if user-id
    (let [data (aget sessions user-id)]
      (js/console.log "Found persistent session for:" user-id)
      (-> (restore-client! (aget data "session")
                           (aget data "passphrase")
                           (aget data "storeId")
                           start-sync!)
          (p/catch (fn [e]
                     (js/console.error "Restore failed (invalidating session):" e)
                     (.clear store user-id)
                     ))))
    (js/console.log "No session found. Waiting for user login.")))))
#+end_src
